Microsoft (R) Macro Assembler Version 6.14.8444		    10/21/22 20:01:31
op.asm							     Page 1 - 1


				.MODEL SMALL
				.STACK 100h

 0000				.DATA
 0000 45 58 50 52 45 53		TitleMessage db 'EXPRESSION: 4 * A - 2 * (C + B)', 0Dh, 0Ah, '$'
       53 49 4F 4E 3A 20
       34 20 2A 20 41 20
       2D 20 32 20 2A 20
       28 43 20 2B 20 42
       29 0D 0A 24
 0022 0D 0A 4F 56 45 52		OverflowMessage db 0Dh, 0Ah, 'OVERFLOW!$' ; 0Dh = 13d = \r = CR, 0Ah = 10d = \n = LF
       46 4C 4F 57 21 24
 002E 0D 0A 45 52 52 4F		ErrorNumberMessage db 0Dh, 0Ah, 'ERROR NUMBER!$'
       52 20 4E 55 4D 42
       45 52 21 24
 003E 45 6E 74 65 72 20		EnterNumberA db 'Enter number A: $'
       6E 75 6D 62 65 72
       20 41 3A 20 24
 004F 45 6E 74 65 72 20		EnterNumberB db 'Enter number B: $'
       6E 75 6D 62 65 72
       20 42 3A 20 24
 0060 45 6E 74 65 72 20		EnterNumberC db 'Enter number C: $'
       6E 75 6D 62 65 72
       20 43 3A 20 24
 0071 52 65 73 75 6C 74		ResultNumber db 'Result number: $'
       20 6E 75 6D 62 65
       72 3A 20 24

 0000				.CODE

				; Получает число посимвольно с клавиатуры
				; OUTPUT: AX
 0000				getNumber proc
 0000  33 DB				xor bx, bx ; для входного числа
 0002  33 C9				xor cx, cx ; флаг знака
					
 0004  B4 01				mov ah, 01h ; функция ввода нового символа
 0006  CD 21				int 21h ; вызов прерывания
					
 0008  3C 2D				cmp al, '-' ; если нажали -, то отрицательное число
 000A  75 0B				jne notNegativeInput
 000C  B9 0001				mov cx, 1 ; cx := 1
					
 000F					nextNumberInput:
 000F  B4 01					mov ah, 01h ; функция ввода нового символа
 0011  CD 21					int 21h

 0013  3C 0D					cmp al, 0Dh ; если нажали enter, то это конец числа 
 0015  74 19					je endNumber

 0017					notNegativeInput:
 0017  3C 30					cmp al, 30h ; если введен неверный символ < 0
 0019  7C 20					jl inputError
 001B  3C 39					cmp al, 39h ; если введен неверный символ > 9
 001D  7F 1C					jg inputError
						
 001F  2C 30					sub al, 30h ; делаем из введенного символа число
 0021  32 E4					xor ah, ah ; ah := 0
						
						; ax - введенная цифра
						; bx - полное число
 0023  93					xchg ax, bx ; (ax, bx) := (bx, ax)
						; ax - полное число
						; bx - введенная цифра
						
 0024  BA 000A					mov dx, 0Ah ; dx := 10
 0027  F7 E2					mul dx ; умножаем на основание системы счисления = 10, dx:ax := dx * ax
						
 0029  E8 0025					call checkOverflow ; проверка переполнения
						
 002C  03 D8					add bx, ax ; прибавляем новое число, bx := bx + ax

 002E  EB DF					jmp nextNumberInput
					
 0030					endNumber:
 0030  8B C3					mov ax, bx ; ax := bx
 0032  83 F9 01					cmp cx, 1 ; если cx = 1, то число отрицательное
 0035  74 01					je negativeEnd
 0037  C3					ret
					
 0038					negativeEnd:
 0038  F7 D8					neg ax ; смена знака числа
 003A  C3					ret
					
 003B					inputError:
 003B  BA 002E R				mov dx, offset ErrorNumberMessage
 003E  E8 0003					call printMessage ; вывод сообщения
 0041  E8 0007					call exitProgram

 0044				getNumber endp

				; Печатает сообщение из регистра DX
				; INPUT: DX
 0044				printMessage proc
 0044  50				push ax
					
 0045  B4 09				mov ah, 09h ; номер прерывания
 0047  CD 21				int 21h ; вызов прерывания
					
 0049  58				pop ax
 004A  C3				ret
 004B				printMessage endp

				; Закрывает программу
 004B				exitProgram proc
 004B  B8 4C00				mov ax, 4C00h ; выход из программы
 004E  CD 21				int 21h
 0050  C3				ret
 0051				exitProgram endp

				; Проверка на переполнение
 0051				checkOverflow proc
 0051  70 01				jo overflowNumber ; проверка переполнения
 0053  C3				ret
					
 0054					overflowNumber:
 0054  BA 0022 R				mov dx, offset OverflowMessage
 0057  E8 FFEA					call printMessage ; вывод сообщения
 005A  E8 FFEE					call exitProgram
 005D				checkOverflow endp

				; Печатает число из регистра AX
				; INPUT: AX
 005D				printNumber proc
					; Проверяем число на знак.
 005D  85 C0				test ax, ax ; test == and, но без изменения регистра ax -------------------------
 005F  79 0C				jns notNegative ; результат неотрицательный => notNegative

					; Если оно отрицательное, выведем минус и оставим его модуль.
 0061  8B C8				mov cx, ax
 0063  B4 02				mov ah, 02h
 0065  B2 2D				mov dl, '-'
 0067  CD 21				int 21h
 0069  8B C1				mov ax, cx
 006B  F7 D8				neg ax ; смена знака числа

 006D					notNegative:
 006D  33 C9					xor cx, cx ; cx=0, счетчик
 006F  BB 000A					mov bx, 0Ah ; перевод в 10-ую сс

 0072					nextNumber:
 0072  33 D2					xor dx, dx ; dx = 0
 0074  F7 F3					div bx ; ax mod bx -> dx, ax div bx -> ax
 0076  52					push dx ; в стек
 0077  41					inc cx ; +1
 0078  23 C0					and ax, ax
 007A  75 F6					jnz nextNumber ; переход по не равно нулю
						
 007C					printNumberFromStack:
 007C  B4 02					mov ah, 02h ; функция вывода символа
 007E  5A					pop dx
 007F  80 C2 30					add dl, 30h
 0082  CD 21					int 21h
 0084  49					dec cx ; -1
 0085  75 F5					jnz printNumberFromStack ; переход по не равно нулю
 0087  C3					ret
 0088				printNumber endp

 0088				main:
 0088  B8 ---- R			mov ax, @data ; смещение для данных
 008B  8E D8				mov ds, ax ; указание сегмента данных
					
 008D  BA 0000 R			mov dx, offset TitleMessage ; вывод заголовка программы
 0090  E8 FFB1				call printMessage ; вывод сообщения
					
					; Ввод чисел A, B, C
 0093  BA 003E R			mov dx, offset EnterNumberA
 0096  E8 FFAB				call printMessage ; вывод сообщения
 0099  E8 FF64				call getNumber
 009C  50				push ax
					
 009D  BA 004F R			mov dx, offset EnterNumberB
 00A0  E8 FFA1				call printMessage ; вывод сообщения
 00A3  E8 FF5A				call getNumber
 00A6  50				push ax
					
 00A7  BA 0060 R			mov dx, offset EnterNumberC
 00AA  E8 FF97				call printMessage ; вывод сообщения
 00AD  E8 FF50				call getNumber
 00B0  50				push ax

					; Достаем из стека
 00B1  59				pop cx
 00B2  5B				pop bx
 00B3  58				pop ax
					
 00B4  03 D9				add bx, cx ; bx := bx + cx = b + c
 00B6  E8 FF98				call checkOverflow ; проверка переполнения
					
 00B9  D1 E3				shl bx, 1 ; сдвиг влево => bx := bx * 2 = (b + c) * 2
 00BB  E8 FF93				call checkOverflow ; проверка переполнения

 00BE  D1 E0				shl ax, 1 ; сдвиг влево => ax := ax * 2 = a * 2
 00C0  E8 FF8E				call checkOverflow ; проверка переполнения
					
 00C3  D1 E0				shl ax, 1 ; сдвиг влево => ax := ax * 2 = a * 4
 00C5  E8 FF89				call checkOverflow ; проверка переполнения

 00C8  2B C3				sub ax, bx ; ax := ax - bx = a * 4 - (b + c) * 2
 00CA  E8 FF84				call checkOverflow ; проверка переполнения
					
 00CD  BA 0071 R			mov dx, offset ResultNumber
 00D0  E8 FF71				call printMessage ; вывод сообщения
 00D3  E8 FF87				call printNumber
					
 00D6  B8 4C00				mov ax, 4C00h ; выход из программы
 00D9  CD 21				int 21h
				end main
Microsoft (R) Macro Assembler Version 6.14.8444		    10/21/22 20:01:31
op.asm							     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0081	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0100	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 00DB	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

checkOverflow  . . . . . . . . .	P Near	 0051	  _TEXT	Length= 000C Public
  overflowNumber . . . . . . . .	L Near	 0054	  _TEXT	
exitProgram  . . . . . . . . . .	P Near	 004B	  _TEXT	Length= 0006 Public
getNumber  . . . . . . . . . . .	P Near	 0000	  _TEXT	Length= 0044 Public
  nextNumberInput  . . . . . . .	L Near	 000F	  _TEXT	
  notNegativeInput . . . . . . .	L Near	 0017	  _TEXT	
  endNumber  . . . . . . . . . .	L Near	 0030	  _TEXT	
  negativeEnd  . . . . . . . . .	L Near	 0038	  _TEXT	
  inputError . . . . . . . . . .	L Near	 003B	  _TEXT	
printMessage . . . . . . . . . .	P Near	 0044	  _TEXT	Length= 0007 Public
printNumber  . . . . . . . . . .	P Near	 005D	  _TEXT	Length= 002B Public
  notNegative  . . . . . . . . .	L Near	 006D	  _TEXT	
  nextNumber . . . . . . . . . .	L Near	 0072	  _TEXT	
  printNumberFromStack . . . . .	L Near	 007C	  _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP
EnterNumberA . . . . . . . . . .	Byte	 003E	  _DATA	
EnterNumberB . . . . . . . . . .	Byte	 004F	  _DATA	
EnterNumberC . . . . . . . . . .	Byte	 0060	  _DATA	
ErrorNumberMessage . . . . . . .	Byte	 002E	  _DATA	
OverflowMessage  . . . . . . . .	Byte	 0022	  _DATA	
ResultNumber . . . . . . . . . .	Byte	 0071	  _DATA	
TitleMessage . . . . . . . . . .	Byte	 0000	  _DATA	
main . . . . . . . . . . . . . .	L Near	 0088	  _TEXT	

	   0 Warnings
	   0 Errors
